'''
Created on Jan 17, 2017

@author: aconstantino
'''

''' Imports '''

import sys

''' Initial Setup Constants and Global Variables '''
Nb = 4 # Number of words in a block
Nr = 0 # Number of rounds, will be set in Main
Nk = 0 # Number words in key, will be set in Main

currState = [[],[],[],[]] # What we are currently encrypting 4x4 array

rotatedWord = []

subbedWord = []

roundKey = [] # Extended key size 240
#for i in range(240):
#	roundKey.append(0)

key = [] # Original key size 32
#for i in range(32):
#	key.append(0)

Rcon = [0x00, # Rcon[] is 1-based, so the first entry is just a place holder 
	0x01, 0x02, 0x04, 0x08,
	0x10, 0x20, 0x40, 0x80,
	0x1B, 0x36, 0x6C, 0xD8,
	0xAB, 0x4D, 0x9A, 0x2F,
	0x5E, 0xBC, 0x63, 0xC6,
	0x97, 0x35, 0x6A, 0xD4,
	0xB3, 0x7D, 0xFA, 0xEF,
	0xC5, 0x91, 0x39, 0x72,
	0xE4, 0xD3, 0xBD, 0x61,
	0xC2, 0x9F, 0x25, 0x4A,
	0x94, 0x33, 0x66, 0xCC,
	0x83, 0x1D, 0x3A, 0x74,
	0xE8, 0xCB, 0x8D]

Sbox = [
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]

InvSbox = [
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]

''' Key function definitions '''

def subWord(word):
	global subbedWord
	subbedWord = []
	for i in range(4):
		subbedWord.append(Sbox[word[i]])
	
def rotWord(word):
	global rotatedWord
	rotatedWord = []
	for i in range(1,4):
		rotatedWord.append(word[i])
	rotatedWord.append(word[0])
	
def keyExpansion():

	global roundKey

	temp = [0,0,0,0] # Create fixed array

	for i in range(Nk):
		roundKey.append(key[4*i])
		roundKey.append(key[4*i+1])
		roundKey.append(key[4*i+2])
		roundKey.append(key[4*i+3])

	i = Nk
	
	#keyPrinter()
	#roundKeyPrinter()

	while i < (Nb * (Nr+1)):

		for j in range(4):
			temp[j] = roundKey[(i-1) * 4 + j]

		if (i % Nk) == 0:
			rotWord(temp)
			subWord(rotatedWord)
			for j in range(4):
				temp[j] = subbedWord[j]
			#print(' '.join(format(c, '02x') for c in temp))
			temp[0] = temp[0] ^ Rcon[i//Nk]

		elif (Nk > 6) and (i % Nk == 4):
			subWord(temp)
			for j in range(4):
				temp[j] = subbedWord[j]

		for j in range(4):
			roundKey.append(roundKey[(i-Nk) * 4 + j] ^ temp[j])

		i += 1

		#roundKeyPrinter()	
	
def subBytes():
	global currState
	for i in range(4): # For each row
		for j in range(4): # For each column
			currState[i][j] = Sbox[currState[i][j]]

def invSubBytes():
	global currState
	for i in range(4): # For each row
		for j in range(4): # For each column
			currState[i][j] = InvSbox[currState[i][j]]

def shiftRows():

	global currState

	temp1 = currState[1][0]
	currState[1][0] = currState[1][1]
	currState[1][1] = currState[1][2]
	currState[1][2] = currState[1][3]
	currState[1][3] = temp1

	temp1 = currState[2][0]
	temp2 = currState[2][1]
	currState[2][0] = currState[2][2]
	currState[2][1] = currState[2][3]
	currState[2][2] = temp1
	currState[2][3] = temp2
	
	temp1 = currState[3][0]
	temp2 = currState[3][1]
	temp3 = currState[3][2]
	currState[3][0] = currState[3][3]
	currState[3][1] = temp1
	currState[3][2] = temp2
	currState[3][3] = temp3

	
def invShiftRows():

	global currState

	for i in range(4): # For each row
		newRow = [0,0,0,0] # Create fixed array
		for j in range(4): # For each column
			pos = (i + j) % 4
			newRow[pos] = currState[i][j]
		currState[i][0] = newRow[0]
		currState[i][1] = newRow[1]
		currState[i][2] = newRow[2]
		currState[i][3] = newRow[3]

def ffAdd(x, y):
	return x ^ y

def xTime(x):
	hibit = x & 0x80
	x <<= 1
	if hibit == 0x80:
		x ^= 0x11b
	return x
	
def ffMultiply(x, y):
	z = 0x00
	for i in range(8):
		if y & 1 == 1:
			z = ffAdd(z, x)
		x = xTime(x)
		y >>= 1
	return z % 256

def mixColumns():

	global currState

	newState = [[],[],[],[]] # Create an new state in a 4x4 array

	for i in range(4): # For each row
		for j in range(4): # For each column
			newState[i].append(currState[i][j])
		#newState[i] = currState[i] # Copy each column

	m = [[0x02, 0x03, 0x01, 0x01],
		[0x01, 0x02, 0x03, 0x01],
		[0x01, 0x01, 0x02, 0x03],
		[0x03, 0x01, 0x01, 0x02]]

	for c in range(4): # Increment by column instead of row
		newState[0][c] = ffMultiply(currState[0][c], m[0][0]) ^ ffMultiply(currState[1][c], m[0][1]) ^ ffMultiply(currState[2][c], m[0][2]) ^ ffMultiply(currState[3][c], m[0][3])
		newState[1][c] = ffMultiply(currState[0][c], m[1][0]) ^ ffMultiply(currState[1][c], m[1][1]) ^ ffMultiply(currState[2][c], m[1][2]) ^ ffMultiply(currState[3][c], m[1][3])
		newState[2][c] = ffMultiply(currState[0][c], m[2][0]) ^ ffMultiply(currState[1][c], m[2][1]) ^ ffMultiply(currState[2][c], m[2][2]) ^ ffMultiply(currState[3][c], m[2][3])
		newState[3][c] = ffMultiply(currState[0][c], m[3][0]) ^ ffMultiply(currState[1][c], m[3][1]) ^ ffMultiply(currState[2][c], m[3][2]) ^ ffMultiply(currState[3][c], m[3][3])

	
	for i in range(4): # For each row
		for j in range(4): # For each column
			currState[i][j]  = newState[i][j]

# Same as normal mixColumns but the m matrix is different
def invMixColumns():

	global currState

	newState = [[],[],[],[]] # Create an new state in a 4x4 array

	for i in range(4): # For each row
		for j in range(4): # For each column
			newState[i].append(currState[i][j])
		#newState[i] = currState[i] # Copy each column	

	m = [[0x0e, 0x0b, 0x0d, 0x09],
		[0x09, 0x0e, 0x0b, 0x0d],
		[0x0d, 0x09, 0x0e, 0x0b],
		[0x0b, 0x0d, 0x09, 0x0e]]

	for c in range(4): # Increment by column instead of row
		newState[0][c] = ffMultiply(currState[0][c], m[0][0]) ^ ffMultiply(currState[1][c], m[0][1]) ^ ffMultiply(currState[2][c], m[0][2]) ^ ffMultiply(currState[3][c], m[0][3])
		newState[1][c] = ffMultiply(currState[0][c], m[1][0]) ^ ffMultiply(currState[1][c], m[1][1]) ^ ffMultiply(currState[2][c], m[1][2]) ^ ffMultiply(currState[3][c], m[1][3])
		newState[2][c] = ffMultiply(currState[0][c], m[2][0]) ^ ffMultiply(currState[1][c], m[2][1]) ^ ffMultiply(currState[2][c], m[2][2]) ^ ffMultiply(currState[3][c], m[2][3])
		newState[3][c] = ffMultiply(currState[0][c], m[3][0]) ^ ffMultiply(currState[1][c], m[3][1]) ^ ffMultiply(currState[2][c], m[3][2]) ^ ffMultiply(currState[3][c], m[3][3])

	for i in range(4): # For each row
		for j in range(4): # For each column
			currState[i][j]  = newState[i][j]
	
def addRoundKey(roundNum):
	global currState
	for i in range(4): # For each row
		for j in range(4): # For each column
			currState[j][i] = currState[j][i] ^ roundKey[roundNum*Nb*4+i*Nb+j]

def cipher():
	
	addRoundKey(0) # First round

	statePrinter()

	for i in range(1,Nr): # For the number of rounds 2 to Nr-1
		subBytes()
		statePrinter()
		shiftRows()
		statePrinter()
		mixColumns()
		statePrinter()
		addRoundKey(i)
		statePrinter()
	# Final round
	subBytes()
	shiftRows()
	addRoundKey(Nr)

def invCipher():
	
	addRoundKey(Nr) # Start at the end

	for i in range(Nr-1,0,-1): # For the number of round starting with Nr-1 to 2 counting down
		invShiftRows()
		invSubBytes()
		addRoundKey(i)
		invMixColumns()

	# Final round
	invShiftRows()
	invSubBytes()
	addRoundKey(0)

def statePrinter():
	for r in currState:
		print(' '.join(format(c, '02x') for c in r))
	print('')

def keyPrinter():
	print(' '.join(format(c, '02x') for c in key))
	
def roundKeyPrinter():
	print(' '.join(format(c, '02x') for c in roundKey))

def main():

	global Nk
	global Nr
	global key
	global currState

	# Parameters from appendix B in FIPS
	#inputData = [0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34]
	#key128 = [0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c]

	# Input data from appendix C in FIPS 
	inputData = [0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff]
	# 128 key from appendix C in FIPS 
	key128 = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f]
	# 192 key from appendix C in FIPS 
	key192 = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17]
	# 256 key from appendix C in FIPS 
	key256 = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f]

	keyLen = int(sys.argv[1])
	currentKey = []

	if keyLen == 128:
		currentKey = key128
	elif keyLen == 192:
		currentKey = key192
	elif keyLen == 256:
		currentKey = key256
	else:
		print('You have entered an invalid key length')
		sys.exit(0)

	Nk = len(currentKey)//4
	Nr = Nk + 6
	print(' '.join(format(k , '02x') for k in key), Nk, Nr)
	
	for i in range(Nk*4):
		key.append(currentKey[i])

	for i in range(4): # For each row
		for j in range(4): # For each column
			currState[j].append(inputData[i*4 + j])

	statePrinter()

	keyExpansion()
	cipher()

	statePrinter()
	invCipher()

	statePrinter()

if __name__ == '__main__':
	main()